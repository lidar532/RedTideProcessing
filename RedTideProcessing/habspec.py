# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_habspec.ipynb.

# %% auto 0
__all__ = ['hhmmss_to_sod', 'now_utc', 'hms2sod', 'extract_hms', 'configure_json_spectra', 'calibrate_using_2_wavelengths',
           'read_spectra', 'get_list_of_json_spectra', 'json_specs_to_df', 'is_water', 'wavelength_2_RGB',
           'wavelength_2_RGB_str', 'nearest_rgb_image', 'read_gps_file_to_df', 'compute_gps_positions', 'get_bearing',
           'get_list_of_flight_lines', 'get_list_of_hab_files', 'get_fluorescence', 'get_fluorescence_700',
           'get_fluorescence_683']

# %% ../nbs/05_habspec.ipynb 4
import glob
import numpy             as np
import pandas            as pd
import cv2               as cv
import datetime          as dt
import glob
import matplotlib.pylab  as plt
import numpy             as np
import pandas            as pd
import pandas            as pd
import time
from geographiclib.geodesic import Geodesic
from           PIL          import Image   
from       skimage          import io

# %% ../nbs/05_habspec.ipynb 19
def hhmmss_to_sod( hhmmss, Usecs=0):
    """
    Converts a time string in 'HHMMSS' format to a seconds-of-the-day
    including an optional microseconds fraction.

    Parameters:
    ----------- 
    hhmmss : str
    Usecs  : str, default=0

    Returns: 
    --------
    float
      Seconds of the day including the fractional part computed from `Usecs`
    
    Description:
    ------------
    hhmmss where hh is hours, mm is minutes, and ss is seconds. Example '123456'
    is 12 hours, 34 minutes, and 56 seconds. A string representing the number of
    microseconds since the last second increment, ie the fractional part of a second. 
    Example: '954561' represents 0.954561 seconds, or 954,561 microseconds since the
    last seconds rollover. Returns A single floating point value of the seconds since
    midnight plus the fractional seconds.

    Examples:
    ---------
    To be added.

    """
    hh = int(hhmmss[0:2])
    mm = int(hhmmss[2:4])
    ss = int(hhmmss[4:6])
    fsod = hh*3600 + mm*60 + ss + float(Usecs) * 1e-6
    return fsod

# %% ../nbs/05_habspec.ipynb 21
def now_utc( fmt='%Y-%m%d %H:%M:%S'):
    """ Return the current UTC date and time as a string.  Example return: '2021-0812 15:39:41'.
    See: http://shorturl.at/koOQ7 for timeformat options & directives.
    """
    t = dt.datetime.utcnow()
    ts = f'{t:{fmt}}'
    return ts

# %% ../nbs/05_habspec.ipynb 24
def hms2sod( str ):
  '''
  Converts an ASCII string in the form 'HH:MM"SS' to seconds of the day. Works with
  fractional seconds.
  '''
  t_lst = str.split('.')
  ts = time.strptime( t_lst[0], '%H:%M:%S')
  if len(t_lst) > 1:
    fs = float("."+t_lst[1] )
  else:
    fs = 0.0
  sod = ts[3]*3600 + ts[4]*60 + ts[5] + fs
  return sod

# %% ../nbs/05_habspec.ipynb 27
def extract_hms( 
  fn:str         # Filename 
) ->tuple:       # ( hhmmss:str, fsecs:str, hhmmss.fsecs:float, sod.fsecs:float )
    '''Extract the HHMMSS and Fsecs strings from filename "fn"

    Returns:
    --------
    ( hhmmss:str, fsecs:str, hhmmss.fsecs:float, sod.fsecs:float )
    '''
    lst = fn.split('-')
    sod = hhmmss_to_sod( lst[-3], Usecs=lst[-2] )
    return ( lst[-3], lst[-2], float(lst[-3])+float(lst[-2])*1e-6, sod  )

# %% ../nbs/05_habspec.ipynb 30
def configure_json_spectra(
  hab_spectra_class,  # The HAB_Spectra class to update.
  file_name:str       # Json settings file.
) ->bool:              # Returns True if successful, else False.
    '''
    Configures HabSpec internal setting according to settings found within a json spectra file 'file_name'.
    '''
    try:
      spec = pd.read_json(file_name)                                                     # get a spectra fron a json file to pandas.
    except:
      hab_spectra_class.error_msgs = f"configure_json_spectra() failed. Unable to read: {file_name}."
    try:
      hab_spectra_class.json_spectra_file_name = file_name
      hab_spectra_class.raw_y                  = y = np.array(spec['hab_spec'].spectra ) # Load the y values to an np array
      hab_spectra_class.summed_rows            = spec['hab_spec'].summed_rows
      hab_spectra_class.Xpixels                = np.arange( 0 ,y.size )                  # Construct an array of X values from 0 to y.size
      hab_spectra_class.wavelengths            = np.arange(    y.size )                  # construce, but don't fillin. Leave for calibration.
      rv = True
      hab_spectra_class.error_msgs = ""
      hab_spectra_class.Configured = True
    except:
      rv = False
      hab_spectra_class.error_msgs = "configure_json_spectra() failed trying to set variables."
    return rv

# %% ../nbs/05_habspec.ipynb 34
def calibrate_using_2_wavelengths(
                                  hab_spectra_class:object, # The HAB_Spectra class to update.
                                  spectra_file_name:str,    # Filename of a json spectra file.
                                  pixel0:int=0,             #  pixel # for Wavelength 0
                                  wavelength0:float=0,      # Wavelength of pixel 0
                                  pixel1:int=0,             # pixel # for Wavelength 1
                                  wavelength1:float=0       # Wavelength for pixel1
                                 ) ->bool:                  # True on success, False otherwise.
    '''
    Generate a Numpy array of calibration wavelenghts for each pixel. configure_json_spectra(f)
    must be called beforehand inrder to set the correct number of pixels.

    Example:
    ---------
    # Configure the spectra by reading a spectra file.
    fn = '/content/drive/MyDrive/Missions/2021-0717-HAB-pie/165347/hab_spectra/2021-0717-165348-272814-spec.json'
    hs.configure_json_spectra(fn)

    # Calibrate the spectra.  Pixel 73 is at 430.774nm, and pixel 941 is at 759.370nm
    hs.calibrate_using_2_wavelengths(pixel0=73, wavelength0=430.774, pixel1=941, wavelength1=759.370 )

    References:
    -----------
    The following are wavelength calibration sources.
    See: http://hyperphysics.phy-astr.gsu.edu/hbase/quantum/atspect2.html
    and: https://commons.wikimedia.org/wiki/File:Fluorescent_lighting_spectrum_peaks_labelled.gif
    and: https://en.wikipedia.org/wiki/Fluorescent_lamp#/media/File:Spectra-Philips_32T8_natural_sunshine_fluorescent_light.svg
    '''
    rv = configure_json_spectra(hab_spectra_class,  spectra_file_name )
    if rv:
      try:
        hab_spectra_class.pixel0              = pixel0
        hab_spectra_class.pixel1              = pixel1
        hab_spectra_class.wavelength0         = wavelength0
        hab_spectra_class.wavelength1         = wavelength1

        dp                                    = pixel1 - pixel0            # pixel delta
        hab_spectra_class.delta_pix           = dp 

        dw                                    = wavelength1 - wavelength0  # Wavelength delta
        hab_spectra_class.delta_wavelength_nm = dw

        slope                                 = dw/dp                      # Linear slope
        hab_spectra_class.wavelengths         = wavelength0 + (hab_spectra_class.Xpixels-pixel0) * slope
        hab_spectra_class.Calibrated_w        = True
        rv = True
      except:
        rv = False
        hab_spectra_class.error_msgs += " calibrate_using_2_wavelengths() failed."
    return rv

# %% ../nbs/05_habspec.ipynb 38
def read_spectra( hab_spectra_class,      # The HAB_Spectra class to update.                
                 spectra_json_file_name,  # JSON Spectra file name
                   remove_bias = True,    # Bol remove bias
                   y_average   = True     # Average Y values
                  ) -> float:             # Numpy array of spectral points.
    """
    Reads a Json hyperspectra file.  Note: Any data older than 2022-12 does not have
    GPS info in the json spectra.  The GPS data is recorded in a separate file.

    Parameters:
    -----------
    spectra_json_file_name : str
      The full path name of a hyperspectra Json file.
    remove_bias : Default True
      Subtracts the minimum y value from the array of y values to remove dark current. 
      The minimum value will typically be found in the IR side and from the pixel 
      sensors that are optically obscured.
    y_average : Default True
      The Json values are the sum total of each pixel column. Each column contains 800
      pixels. Setting this to True causes the read y values to be divided by 800.

    Returns:
    --------
    Numpy array
      An array of numpy float values representing the intensity values at each pixel. 

    Description:
    ------------
    Reads a Json spectra from a file.

    Examples:
    ---------
    fn = '/content/drive/MyDrive/Missions/2021-0717-HAB-pie/165347/hab_spectra/2021-0717-165348-272814-spec.json'
    s = hs.read_spectra(fn) 
    """
    spec = pd.read_json(spectra_json_file_name)
    hab_spectra_class.json_spectra_file_name = spectra_json_file_name
    try:
      hab_spectra_class.DateTime        = spec['hab_spec']['DateTime']
      hab_spectra_class.Exposure        = spec['hab_spec']['Exposure']
      hab_spectra_class.GPS_Alt         = spec['hab_spec']['GPS_Alt']
      hab_spectra_class.GPS_Nsat_Inview = spec['hab_spec']['GPS_Nsat_Inview']
      hab_spectra_class.GPS_Status      = spec['hab_spec']['GPS_Status']
      hab_spectra_class.GPS_UTC         = spec['hab_spec']['GPS_UTC']
      hab_spectra_class.Lat             = spec['hab_spec']['Lat']
      hab_spectra_class.Lon             = spec['hab_spec']['Lon']
      hab_spectra_class.Source          = spec['hab_spec']['Source']
      hab_spectra_class.Pix_minv        = spec['hab_spec']['Pix_minv']
      hab_spectra_class.sat_pix_n       = spec['hab_spec']['sat_pix_n']
      hab_spectra_class.Pix_maxv        = spec['hab_spec']['Pix_maxv']
      hab_spectra_class.Pix_maxv        = spec['hab_spec']['Pix_maxv']
    except:
      hab_spectra_class.DateTime        = None
      hab_spectra_class.Exposure        = None
      hab_spectra_class.GPS_Alt         = None
      hab_spectra_class.GPS_Nsat_Inview = None
      hab_spectra_class.GPS_Status      = None
      hab_spectra_class.GPS_UTC         = None
      hab_spectra_class.Lat             = None
      hab_spectra_class.Lon             = None
      hab_spectra_class.Source          = None
      hab_spectra_class.Pix_minv        = None
      hab_spectra_class.sat_pix_n       = None
      hab_spectra_class.Pix_maxv        = None
      hab_spectra_class.Pix_maxv        = None
    try:
      hab_spectra_class.summed_rows     = spec['hab_spec']['summed_rows']
    except:
      pass
      
      
    hab_spectra_class.json_spectra_file_name       = spectra_json_file_name
    hab_spectra_class.remove_bias     = remove_bias
    hab_spectra_class.y_average       = y_average
    
    if hab_spectra_class.Configured == 0 :
      configure_json_spectra(hab_spectra_class, spectra_json_file_name)
      
    hab_spectra_class.raw_y = np.array(spec['hab_spec'].spectra)
    
    hab_spectra_class.raw_y_min = hab_spectra_class.raw_y.min()
    
    if remove_bias == True:
      hab_spectra_class.raw_y = hab_spectra_class.raw_y - hab_spectra_class.raw_y_min

    if y_average == True:
      hab_spectra_class.raw_y = hab_spectra_class.raw_y / hab_spectra_class.summed_rows

    return hab_spectra_class.raw_y

# %% ../nbs/05_habspec.ipynb 43
def get_list_of_json_spectra( p        # String path to mission data set.
                            ) ->list:  # List of full paths to each JSON spectra file.
    ''' Returns a list of Json spectra full path filenames found in subdirs under "p". '''
    gstr = f'{p}/*/*/*-spec.json'
    lst = glob.glob(gstr, recursive=True)
    return lst

# %% ../nbs/05_habspec.ipynb 47
def json_specs_to_df( specs ):
    '''
    Extracts the hhmmss and fsecs from 'specs' filename, converts
    the hhmmss and fsecs strings to float SOD.fsecs.

    Parameters:
    specs: list  A list of json spectra files.

    Returns:
    --------
    A DataFrame of sod.fsecs:float, hhmmss:str, Json_spec:str
    '''
    # Extract the hhmmss and fsecs from each file name,
    # convert the hhmmss and fsecs to float SOD.fsecs, 
    # and create a list of each.
    hhmmss = []
    fsecs  = []
    sod    = []
    for v in specs:
      tx = extract_hms( v )
      hhmmss.append( tx[0] )   # Build the list if hhmmss strings.
      sod.append( tx[3] )      # Build the list of sod floats.

    # Now convert the  lists to a Pandas dataframe.
    dct = {'sod':sod, 'hhmmss':hhmmss, 'Json_spec':specs}
    df = pd.DataFrame( dct )
    df.sort_values(by=['sod'], inplace=True)              # Sort the data in time order.
    return df

# %% ../nbs/05_habspec.ipynb 51
def is_water(
  hab_spectra_class  #
  #x,
  #y                 #
) -> float:          #
    '''
    Returns the mean signal value between 840nm and 860nm wavelengths.  Since water absorbs IR.

    Inputs:
      x   A numpy array of wavlengths for each pixel
      y   A numpy array of intensity values at each wavelength.  x and y mus be the same size.

    Returns:
      The mean signal value between 840nm and 860nm.  The signal level is not currently normalized
      for anything, exposure, etc.  Threshold is around 4.0.  Above 4, land or glint.

    References: 
    Application of the water-related spectral reflectance indices: A review
    https://www.sciencedirect.com/science/article/abs/pii/S1470160X18308215

    '''
    rv = hab_spectra_class.raw_y[hsdc.w_range_pixels( hab_spectra_class,840,860)].mean()
    return rv

# %% ../nbs/05_habspec.ipynb 54
def wavelength_2_RGB(
  wavelength,   # Wavelength in nanometers.
  alpha=255     # Alpha to use.
) -> list:      # ( red, green, blue )
  '''
  Convert a wavelength to a tuple of red, green, blue values.
  
  From: https://codingmess.blogspot.com/2009/05/conversion-of-wavelength-in-nanometers.html
  '''
  w = int(wavelength)

  # colour
  if w >= 380 and w < 440:
      R = -(w - 440.) / (440. - 350.)
      G = 0.0
      B = 1.0
  elif w >= 440 and w < 490:
      R = 0.0
      G = (w - 440.) / (490. - 440.)
      B = 1.0
  elif w >= 490 and w < 510:
      R = 0.0
      G = 1.0
      B = -(w - 510.) / (510. - 490.)
  elif w >= 510 and w < 580:
      R = (w - 510.) / (580. - 510.)
      G = 1.0
      B = 0.0
  elif w >= 580 and w < 645:
      R = 1.0
      G = -(w - 645.) / (645. - 580.)
      B = 0.0
  elif w >= 645 and w <= 780:
      R = 1.0
      G = 0.0
      B = 0.0
  else:
      R = 0.0
      G = 0.0
      B = 0.0

  # intensity correction
  if w >= 380 and w < 420:
      SSS = 0.3 + 0.7*(w - 350) / (420 - 350)
  elif w >= 420 and w <= 700:
      SSS = 1.0
  elif w > 700 and w <= 780:
      SSS = 0.3 + 0.7*(780 - w) / (780 - 700)
  else:
      SSS = 0.0
  SSS *= 255

  return [int(SSS*R), int(SSS*G), int(SSS*B), int(alpha)]

# %% ../nbs/05_habspec.ipynb 57
def wavelength_2_RGB_str( 
  wavelength:float,        # Wavelength in nanometers.
  alpha=255                # Alpha, transparency to use.  
) ->str:                   # rgb string such as: "#01abffff"
  '''
  Converts a wavelength to an RGB string suitable to use
  as a color parameter in most applications.
  '''
  rgb  = wavelength_2_RGB(wavelength, alpha=alpha)
  rgbs = f'#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}{rgb[3]:02x}'
  return rgbs

# %% ../nbs/05_habspec.ipynb 81
#debug_nearest_rgb_image = False
def nearest_rgb_image( 
  fn,          # Json spectra file.
  debug=False  # True to debug internals.
) -> str:      # File name of the nearest RGB photo to this json spectra.
    """
    Returns the path/filename to the RGB photo closes in time to `fn`.  `fn` is the
    filename of a Json hyperspectral file.

    Parameters:
    -----------
    fn : str
      Full path/filename of a hyperspectral Json file.

    Returns:
    --------
    str
      A string path/filename of the closes RGB photo.

    Examples:
    ---------

    References:
    -----------
    """
    if debug:
      print(f'debug_nearest_rgb_image(fn): fn={fn}')
    fn_parts = fn.split('/')   # Split path by '/'
    if debug:
      print(f'debug_nearest_rgb_image(fn): fn_parts={fn_parts}')
    rgb_p = fn_parts                          # Make a copy to build the rgb path/filename in.
    if debug:
      print(f'debug_nearest_rgb_image(fn): rgb_p={rgb_p}')    
    rgb_p[-2] = 'hab_rgb'                     # Change the subdir to point to hab_rgb
    rgb_fn = rgb_p[-1].split('-')             # Split the filename by '-' to access parts.
    rgb_fn[-2] = '*'                          # Replace the microseconds with '*' wildcard.
    rgb_fn[-1] = 'rgb.jpg'                    # Change the file tail to rgb.jpg
    rgb_p[-1] = '-'.join(rgb_fn)              # Glue the name back together
    rgb_p2 = '/'.join(rgb_p)                  # Now glue the whole path back together
    rv = glob.glob(rgb_p2)[0]                 # Return the first entry incase there are more than 1.
    if debug:
      print(f'debug_nearest_rgb_image(fn): rv={rv}') 
    return rv


# %% ../nbs/05_habspec.ipynb 84
#debug_read_gps_file_to_df = False
def read_gps_file_to_df( ifn, debug=False):
    '''
    Read a GPS datafile into a dataframe and convert the HH:MM:SS
    to add an SOD column.

    Parameters:
    -----------
    ifn : str
        Input GPS datafile full path name

    Returns:
    --------
    Pandas Dataframe of the GPS data.
    '''
    gps_df = pd.read_csv(ifn, sep='\s+', comment='#')
    gps_df.sort_values(by=['HMS'], inplace=True)
    # Convert the ASCII HH:MM:SS from the GPS to seconds of the day (SOD) and
    # add an 'SOD' column to the gps dataframe.
    sod_lst = []
    for t in gps_df['HMS']:
      sod_lst.append( hms2sod(t))
    gps_df['SOD'] = sod_lst

    # Compute, and add 'Course' to dataframe
    course = []
    for i in  range(len(gps_df)-1):
      course.append ( get_bearing( 
          lat1=gps_df['Lat'].iloc[i], long1=gps_df['Lon'].iloc[i], 
          lat2=gps_df['Lat'].iloc[i+1], long2=gps_df['Lon'].iloc[i+1] 
          ) 
      )
    course.append( 0.0 )      # To make the same length
    gps_df['Course'] = course
    return gps_df

# %% ../nbs/05_habspec.ipynb 88
#debug_compute_gps_positions = False 
def compute_gps_positions(  gps, spec_df, debug=False):
    '''
    Interpolates spectra positions from gps.

    Parameters:
    -----------
    gps : dataframe
        A dataframe of overlapping gps position data.

    spec_df : dataframe
        A dataframe of values vs time from the spectrometer.

    Returns:
    --------
    See: https://numpy.org/doc/stable/reference/generated/numpy.interp.html
    '''
    spec_df['Lat']    = np.interp(spec_df['sod'], gps['SOD'], gps['Lat'])
    spec_df['Lon']    = np.interp(spec_df['sod'], gps['SOD'], gps['Lon'])
    spec_df['Elev']   = np.interp(spec_df['sod'], gps['SOD'], gps['Elev'])
    spec_df['Course'] = np.interp(spec_df['sod'], gps['SOD'], gps['Course'])
    return spec_df

# %% ../nbs/05_habspec.ipynb 90
#debug_get_bearing = False
def get_bearing( lat1=0, lat2=0, long1=0, long2=0, debug=False):
    '''
    Comutes and returns the bearing between two lat/lon pairs.
    See:
        http://shorturl.at/atGHN
    '''
    brng = Geodesic.WGS84.Inverse(lat1, long1, lat2, long2)['azi1']
    return brng

# %% ../nbs/05_habspec.ipynb 93
#debug_get_list_of_flight_lines = False
def get_list_of_flight_lines( p, debug=False):
    '''Returns a list of flightline subdirs on path p.

    Parameters:
    -----------
    p : str
        Path name.

    Returns:
    --------
    list
        A list of full pathnames to individul flightlines.
    '''
    l = glob.glob(p+'/[0-9]*[!a-z]')
    return l

# %% ../nbs/05_habspec.ipynb 97
#debug_get_list_of_hab_files = False
def get_list_of_hab_files( p, subdir='', ext='', debug=False):
    '''Returns a list of hab files in p/subdir with the specified file extension.  
    
    Parameters:
    p : str
    subdir : str Default = ''
    ext : str Default = ''

    Returns:
    --------
    list
        A list of  full pathnames.
    '''
    gs = p+f'/{subdir}/*.'+ext
    js = glob.glob(gs)
    return js

# %% ../nbs/05_habspec.ipynb 107
#debug_get_fluorescence = False
def get_fluorescence( x, y, fl_start=0, fl_stop=0, base_start=0, base_stop=0, debug=False ):
    '''
    '''
    fl_sig = y[w_range_pixels(x, fl_start, fl_stop )].mean()         # Get the Fluor signal mean value
    by = y[w_range_pixels(x, base_start, base_start+1)].mean()
    ey = y[w_range_pixels(x, base_stop, base_stop+1)].mean()
    center_nm = (fl_stop - fl_start) / 2  + fl_start                                       # Compute center wavelength
    dydx = (ey - by)/(base_stop - base_start )
    sf = dydx * (center_nm - base_start)
    rv = fl_sig + sf
    if debug:
      print('get_fluorescence():', fl_sig, by, ey, center_nm, dydx, sf, rv)
    return rv

# %% ../nbs/05_habspec.ipynb 109
def get_fluorescence_700( x, y):
    '''
    Returns the fluorescence value at 700nm.
    '''
    rv = get_fluorescence( x, y, fl_start=693, fl_stop=710, base_start=668, base_stop=740 )
    return rv

# %% ../nbs/05_habspec.ipynb 111
def get_fluorescence_683( x, y):
    '''
    Returns the fluorescence value at 683nm.  683nm is Chlorophyll
    '''
    rv = get_fluorescence( x, y, fl_start=678, fl_stop=688, base_start=668, base_stop=740 )
    return rv
